# 设计模式

## 一、创建类

### 1、简单工厂方法模式

```python
# @Time :2024/4/24 20:02
from abc import ABCMeta, abstractmethod


class Payment(metaclass=ABCMeta):
    @abstractmethod
    def pay(self, money):
        pass


class Alipay(Payment):
    def __init__(self, use_huabei=False):
        self.use_huabei = use_huabei

    def pay(self, money):
        if self.use_huabei:
            print(f"花呗支付{money}元")
        else:
            print(f"支付宝余额支付{money}元")


class Wechatpay(Payment):
    def pay(self, money):
        print(f"微信支付{money}元")


class PaymentFactory:
    def creat_payment(self, method):
        if method == 'alipay':
            return Alipay()
        elif method == 'huabei':
            return Alipay(use_huabei=True)
        elif method == 'wechatpay':
            return Wechatpay()
        else:
            raise TypeError(f"没有{method}方法")


pf = PaymentFactory()
p = pf.creat_payment('huabei')
p.pay(100)

```



#### 简单工厂模式的不足：

在简单工厂模式中，只提供了一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了“开闭原则”。在简单工厂模式中，所有的产品都是由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。

#### 说明：

### 2、工厂方法模式：

```python
# @Time :2024/4/24 20:17
from abc import abstractmethod, ABCMeta
from simplefactoryMode import Alipay,Wechatpay
class PaymentFactory(metaclass=ABCMeta):
    @abstractmethod
    def creat_payment(self):
        pass


class Alipayment(PaymentFactory):

    def creat_payment(self):
        return Alipay()

class Wechatpayment(PaymentFactory):
    def creat_payment(self):
        return Wechatpay()

class Huabeiment(PaymentFactory):
    def creat_payment(self):
        return Alipay(use_huabei=True)

fm = Alipayment()
fm.creat_payment().pay(100)
```

定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。

工厂方法模式就是简单工厂模式的进一步抽像。由于面向对象多态性，工厂方法模式保持了简单工厂的有点同时克服了他的缺点。工厂方法模式中，核心的工厂被提升为一个抽象类，将具体的创建工作交给他的子类完成。这个抽象的工厂类仅规定具体工厂实现的接口，而不明确指出如何实例化一个产品类，这使得工厂方法模式允许系统在不修改原有产品结构的情况下轻松的引进新产品。

抽象工厂模式：

提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式 ，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品 当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率

抽象工厂模式包含以下4个角色： AbstractFactory（抽象工厂） ConcreteFactory（具体工厂） AbstractProduct（抽象产品） ConcreteProduct（具体产品）

 ![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180602202023544-1221061678.png)

 

#### 实例：

某快餐点餐台的点餐系统。在一个大的触摸显示屏上，有三类可以选择的上餐品：汉堡等主餐、小食、饮料。当我们选择好自己需要的食物，支付完成后，订单就生成了。

```python
class Burger():
    """
    汉堡
    """
    name=""
    price=0.0
    type='BURGER'
    def getPrice(self):
        return self.price
    def setPrice(self,price):
        self.price=price
    def getName(self):
        return self.name
class CheeseBurger(Burger):
    def __init__(self):
        self.name="cheese burger"
        self.price=10.0
class SpicyChickenBurger(Burger):
    def __init__(self):
        self.name="spicy chicken burger"
        self.price=15.0

class Snack():
    """
    小食类
    """
    name = ""
    price = 0.0
    type = "SNACK"
    def getPrice(self):
        return self.price
    def setPrice(self, price):
        self.price = price
    def getName(self):
        return self.name
class Chips(Snack):
    def __init__(self):
        self.name = "chips"
        self.price = 6.0
class ChickenWings(Snack):
    def __init__(self):
        self.name = "chicken wings"
        self.price = 12.0

class Beverage():
    """
    饮料
    """
    name = ""
    price = 0.0
    type = "BEVERAGE"
    def getPrice(self):
        return self.price
    def setPrice(self, price):
        self.price = price
    def getName(self):
        return self.name
class Coke(Beverage):
    def __init__(self):
        self.name = "coke"
        self.price = 4.0
class Milk(Beverage):
    def __init__(self):
        self.name = "milk"
        self.price = 5.0
#以上的Burger，Snack，Beverage，都可以认为是该快餐店的产品，由于只提供了抽象方法，我们把它们叫抽象产品类，而cheese burger等6个由抽象产品类衍生出的子类，叫作具体产品类。
class FoodFactory():
    """
    抽象工厂foodFactory为抽象的工厂类，而burgerFactory，snackFactory，beverageFactory为具体的工厂类。
    """
    type=""
    def createFood(self,foodClass):
        print(self.type," factory produce a instance.")
        foodIns=foodClass()
        return foodIns
class BurgerFactory(foodFactory):
    def __init__(self):
        self.type="BURGER"
class SnackFactory(foodFactory):
    def __init__(self):
        self.type="SNACK"
class BeverageFactory(foodFactory):
    def __init__(self):
        self.type="BEVERAGE"

if  __name__=="__main__":
    burger_factory=burgerFactory()
    snack_factory=snackFactory()
    beverage_factory=beverageFactory()
    cheese_burger=burger_factory.createFood(cheeseBurger)
    print(cheese_burger.getName(),cheese_burger.getPrice())
    chicken_wings=snack_factory.createFood(chickenWings)
    print(chicken_wings.getName(),chicken_wings.getPrice())
    coke_drink=beverage_factory.createFood(coke)
    print(coke_drink.getName(),coke_drink.getPrice())
```



打印结果：

BURGER factory produce a instance.
cheese burger 10.0
SNACK factory produce a instance.
chicken wings 12.0
BEVERAGE factory produce a instance.
coke 4.0

在实例中，抽象工厂下共有三个具体工厂burgerFactory，snackFactory，beverageFactory，三个工厂分别对应，换言之就是生产三类产品burger，snack，beverage。



#### 模式优点

工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节 能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部 在系统中加入新产品时，完全符合开闭原则

#### 模式缺点

系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销 增加了系统的抽象性和理解难度

#### 模式适用环境

客户端不知道它所需要的对象的类（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建） 抽象工厂类通过其子类来指定创建哪个对象

### 3、抽象工厂模式：

```python
# @Time :2024/4/24 20:25
from abc import ABCMeta, abstractmethod


# -----抽象产品------
class Phoneshell(metaclass=ABCMeta):
    @abstractmethod
    def show_shell(self):
        pass


class CPU(metaclass=ABCMeta):
    @abstractmethod
    def show_cpu(self):
        pass


class OS(metaclass=ABCMeta):
    @abstractmethod
    def show_os(self):
        pass


# -----抽象工厂------
class PhoneFactory(metaclass=ABCMeta):
    @abstractmethod
    def make_shell(self):
        pass

    @abstractmethod
    def make_cpu(self):
        pass

    @abstractmethod
    def make_os(self):
        pass


# -----具体产品------
class SmallShell(Phoneshell):

    def show_shell(self):
        print("小手机壳")


class MiddleShell(Phoneshell):

    def show_shell(self):
        print("中号手机壳")


class AppleShell(Phoneshell):

    def show_shell(self):
        print("苹果手机壳")


class AndCpu(CPU):

    def show_cpu(self):
        print("安卓cpu")


class IosCpu(CPU):

    def show_cpu(self):
        print("苹果cpu")


class Apple(OS):

    def show_os(self):
        print("苹果ios操作系统")


class Android(OS):

    def show_os(self):
        print("安卓操作系统")


# -----具体工厂------

class Miphone(PhoneFactory):

    def make_shell(self):
        return MiddleShell()

    def make_cpu(self):
        return AndCpu()

    def make_os(self):
        return Android()


class Iphone(PhoneFactory):

    def make_cpu(self):
        return IosCpu()

    def make_os(self):
        return Apple()

    def make_shell(self):
        return AppleShell()

# -----客户端------

class Phone:
    def __init__(self,cpu,os,shell):
        self.cpu = cpu
        self.os = os
        self.shell = shell

    def show_info(self):
        print("手机信息：")
        self.cpu.show_cpu()
        self.os.show_os()
        self.shell.show_shell()

def make_phone(factory):
    cpu = factory.make_cpu()
    os = factory.make_os()
    shell = factory.make_shell()
    return Phone(cpu,os,shell)


p1 = make_phone(Iphone())
p1.show_info()


```



#### 模式优点

隔离了具体类的生成，使得客户端并不需要知道什么被创建 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无须修改已有系统，符合开闭原则

#### 模式缺点

增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则

#### 模式适用环境

一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节 系统中有多于一个的产品族，但每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构

### 4、建造者模式

#### 说明：

假如要组装一台电脑，将主板，CPU，内存等部件按照某个稳定的步骤组合，基本过程是不变的，而组成电脑的各个部件却可以是不同性能的，不同价位，或者是不同版本的，当组成电脑的时只需要选择不同的组件就可以按照基本相同的过程造出不同配置的电脑。也就是说建造者模式的意图是将一个复杂对象的构建过程与表示分离，它使用相同的构建步骤作用于不同的子对象以构建出不同表现形式的“复杂对象”。

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180601230834303-1604607847.png)

#### 实例：

从订单的角度构建一个快餐点餐系统



```
class Burger():
    """
    主食类，价格名字
    """
    name=""
    price=0.0
    def getPrice(self):
        return self.price
    def setPrice(self,price):
        self.price=price
    def getName(self):
        return self.name
class cheeseBurger(Burger):
    """
    奶酪汉堡
    """
    def __init__(self):
        self.name="cheese burger"
        self.price=10.0
class spicyChickenBurger(Burger):
    """
    香辣鸡汉堡
    """
    def __init__(self):
        self.name="spicy chicken burger"
        self.price=15.0


class Snack():
    """
    小食类，价格以及名字
    """
    name = ""
    price = 0.0
    type = "SNACK"
    def getPrice(self):
        return self.price
    def setPrice(self, price):
        self.price = price
    def getName(self):
        return self.name
class chips(Snack):
    """
    炸薯条
    """
    def __init__(self):
        self.name = "chips"
        self.price = 6.0
class chickenWings(Snack):
    """
    鸡翅
    """
    def __init__(self):
        self.name = "chicken wings"
        self.price = 12.0

class Beverage():
    """
    饮料
    """
    name = ""
    price = 0.0
    type = "BEVERAGE"
    def getPrice(self):
        return self.price
    def setPrice(self, price):
        self.price = price
    def getName(self):
        return self.name
class coke(Beverage):
    """
    可乐
    """
    def __init__(self):
        self.name = "coke"
        self.price = 4.0
class milk(Beverage):
    """
    牛奶
    """
    def __init__(self):
        self.name = "milk"
        self.price = 5.0


class order():
    """
    订单对象，一个订单中包含一份主食，一份小食，一份饮料
    """
    burger=""
    snack=""
    beverage=""
    def __init__(self,orderBuilder):
        self.burger=orderBuilder.bBurger
        self.snack=orderBuilder.bSnack
        self.beverage=orderBuilder.bBeverage
    def show(self):
        print("Burger:%s"%self.burger.getName())
        print("Snack:%s"%self.snack.getName())
        print("Beverage:%s"%self.beverage.getName())

# 建造者
class orderBuilder():
    """
    orderBuilder就是建造者模式中所谓的“建造者”，
    将订单的建造与表示相分离，以达到解耦的目的。
    在上面订单的构建过程中，如果将order直接通过参数定义好（其构建与表示没有分离），
    同时在多处进行订单生成，此时需要修改订单内容，
    则需要一处处去修改，业务风险也就提高了不少。
    """
    bBurger=""
    bSnack=""
    bBeverage=""
    def addBurger(self,xBurger):
        self.bBurger=xBurger
    def addSnack(self,xSnack):
        self.bSnack=xSnack
    def addBeverage(self,xBeverage):
        self.bBeverage=xBeverage
    def build(self):
        return order(self)

# Director类
class orderDirector():
    """
    在建造者模式中，还可以加一个Director类，用以安排已有模块的构造步骤。
    对于在建造者中有比较严格的顺序要求时，该类会有比较大的用处。
    """
    order_builder=""
    def __init__(self,order_builder):
        self.order_builder=order_builder
    def createOrder(self,burger,snack,beverage):
        self.order_builder.addBurger(burger)
        self.order_builder.addSnack(snack)
        self.order_builder.addBeverage(beverage)
        return self.order_builder.build()

#场景实现
if  __name__=="__main__":
    order_builder=orderBuilder()
    order_builder.addBurger(spicyChickenBurger())
    order_builder.addSnack(chips())
    order_builder.addBeverage(milk())
    order_1=order_builder.build()
    order_1.show()
```



执行结果：

Burger:spicy chicken burger
Snack:chips
Beverage:milk

#### 优点：

使得产品内部表象可以独立的变化，使得客户不必知道产品内部的组成细节。对构建过程更加精细控制，将构建代码和表示代码分开。

#### 缺点：

难以应对”分步骤构建算法“的需求变动。

#### 适用性：

1、需要生成的产品有复杂的内部结构

2、需要生成的产品对象的属性相互依赖，建造者模式可以强破生成顺序。

### 5、单例模式

单例模式是所有设计模式中比较简单的一类，其定义如下：Ensure a class has only one instance, and provide a global point of access to it.（保证某一个类只有一个实例，而且在全局只有一个访问点）

单例模式是指：保证一个类仅有一个实例，并提供一个访问它的全局访问点。具体到此例中，总线对象，就是一个单例，它仅有一个实例，各个线程对总线的访问只有一个`全局访问点`，即惟一的实例，`防止命名空间被污染`。

最常用的实例就是当一个office文档已经被打开时，通过另外一个窗口再次访问时，系统会提示已经被此文档已经被占用，只能以只读方式打开。

#### 实例：

总线是计算机各种功能部件或者设备之间传送数据、控制信号等信息的公共通信解决方案之一。现假设有如下场景：某中央处理器（CPU）通过某种协议总线与一个信号灯相连，信号灯有64种颜色可以设置，中央处理器上运行着三个线程，都可以对这个信号灯进行控制，并且可以独立设置该信号灯的颜色。抽象掉协议细节（用打印表示），如何实现线程对信号等的控制逻辑。
加线程锁进行控制，无疑是最先想到的方法，但各个线程对锁的控制，无疑加大了模块之间的耦合。下面，我们就用设计模式中的单例模式，来解决这个问题。
什么是单例模式？

```python
#encoding=utf8
import threading
import time
#这里使用方法__new__来实现单例模式
class Singleton(object):#抽象单例
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance
#总线
class Bus(Singleton):
    lock = threading.RLock()
    def sendData(self,data):
        self.lock.acquire()
        time.sleep(3)
        print "Sending Signal Data...",data
        self.lock.release()
#线程对象，为更加说明单例的含义，这里将Bus对象实例化写在了run里
class VisitEntity(threading.Thread):
    my_bus=""
    name=""
    def getName(self):
        return self.name
    def setName(self, name):
        self.name=name
    def run(self):
        self.my_bus=Bus()
        self.my_bus.sendData(self.name)

if  __name__=="__main__":
    for i in range(3):
        print "Entity %d begin to run..."%i
        my_entity=VisitEntity()
        my_entity.setName("Entity_"+str(i))
        my_entity.start()
```

输出结果：

Entity 0 begin to run...
Entity 1 begin to run...
Entity 2 begin to run...
Sending Signal Data... Entity_0
Sending Signal Data... Entity_1
Sending Signal Data... Entity_2

在程序运行过程中，三个线程同时运行（运行结果的前三行先很快打印出来），而后分别占用总线资源（后三行每隔3秒打印一行）。虽然看上去总线Bus被实例化了三次，但实际上在内存里只有一个实例。

#### 单例模式的优点：

1、由于单例模式要求在全局内只有一个实例，因而可以节省比较多的内存空间；
2、全局只有一个接入点，可以更好地进行数据同步控制，避免多重占用；
3、单例可长驻内存，减少系统开销。

#### 单例模式的应用举例：

1、生成全局惟一的序列号；
2、访问全局复用的惟一资源，如磁盘、总线等；
3、单个对象占用的资源过多，如数据库等；
4、系统全局统一管理，如Windows下的Task Manager；
5、网站计数器。

#### 缺点

1、单例模式的扩展是比较困难的；
2、赋于了单例以太多的职责，某种程度上违反单一职责原则
3、单例模式是并发协作软件模块中需要最先完成的，因而其不利于测试；
4、单例模式在某种情况下会导致“资源瓶颈”。





## 二、结构型模式

### 1、适配器模式

为了`解决接口不兼容的问题`引进一种接口的兼容机制，就是适配器模式，其通过提供一种适配器类将第三方提供的接口转换为客户希望的接口。生活中的例子例如：手机充电器要将220v的电源转换为手机适合的电压才能充电。这个充电器就起到了适配的作用。

适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。适配器模式 别名为包装器(Wrapper)模式 定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180602221225646-127244387.png)

 

```PYTHON
from abc import ABCMeta, abstractmethod


class Payment(metaclass=ABCMeta):

    @abstractmethod
    def pay(self, money):
        pass


class WechatPay(Payment):
    def pay(self, money):
        print(f"微信支付 {money}元")



class ApplePay:
    def cost(self, money):
        print(f"苹果支付{money}元")


# 适应器类,多继承
class AdoptPayExtend(Payment, ApplePay):
    def pay(self, money):
        self.cost(money)


# 对象适配器类，组合法
class AdoptPayComb(Payment):
    def __init__(self, payment):
        self.payment = payment

    def pay(self, money):
        try:
            self.payment.pay(money)
        except AttributeError:
            self.payment.cost(money)


if __name__ == '__main__':
    p = AdoptPayComb(WechatPay())
    p.pay(100)

```



#### 适配器模式的结构

适配器模式包含以下3个角色： Target（目标抽象类） Adapter（适配器类） Adaptee（适配者类）

##### 实例：

假设某公司A与某公司B需要合作，公司A需要访问公司B的人员信息，但公司A与公司B协议接口不同，该如何处理？先将公司A和公司B针对各自的人员信息访问系统封装了对象接口。 

```python
class ACpnStaff:
    """
    A公司
    """
    name=""
    id=""
    phone=""
    def __init__(self,id):
        self.id=id
    def getName(self):
        print("A protocol getName method...id:%s"%self.id)
        return self.name
    def setName(self,name):
        print("A protocol setName method...id:%s"%self.id)
        self.name=name
    def getPhone(self):
        print("A protocol getPhone method...id:%s"%self.id)
        return self.phone
    def setPhone(self,phone):
        print("A protocol setPhone method...id:%s"%self.id)
        self.phone=phone

class BCpnStaff:
    """
    B公司
    """
    name=""
    id=""
    telephone=""
    def __init__(self,id):
        self.id=id
    def get_name(self):
        print("B protocol get_name method...id:%s"%self.id)
        return self.name
    def set_name(self,name):
        print("B protocol set_name method...id:%s"%self.id)
        self.name=name
    def get_telephone(self):
        print("B protocol get_telephone method...id:%s"%self.id)
        return self.telephone
    def set_telephone(self,telephone):
        print("B protocol get_name method...id:%s"%self.id)
        self.telephone=telephone

class CpnStaffAdapter:
    """
    C公司
    """
    b_cpn=""
    def __init__(self,id):
        self.b_cpn=BCpnStaff(id)
    def getName(self):
        return self.b_cpn.get_name()
    def getPhone(self):
        return self.b_cpn.get_telephone()
    def setName(self,name):
        self.b_cpn.set_name(name)
    def setPhone(self,phone):
        self.b_cpn.set_telephone(phone)

#业务场景
if __name__=="__main__":
    acpn_staff=ACpnStaff("123")
    acpn_staff.setName("X-A")
    acpn_staff.setPhone("10012345678")
    print("A Staff Name:%s"%acpn_staff.getName())
    print("A Staff Phone:%s"%acpn_staff.getPhone())
    bcpn_staff=CpnStaffAdapter("456")
    bcpn_staff.setName("Y-B")
    bcpn_staff.setPhone("99987654321")
    print("B Staff Name:%s"%bcpn_staff.getName())
    print("B Staff Phone:%s"%bcpn_staff.getPhone())
```



打印结果： 

A protocol setName method...id:123
A protocol setPhone method...id:123
A protocol getName method...id:123
A Staff Name:X-A
A protocol getPhone method...id:123
A Staff Phone:10012345678
B protocol set_name method...id:456
B protocol get_name method...id:456
B protocol get_name method...id:456
B Staff Name:Y-B
B protocol get_telephone method...id:456
B Staff Phone:99987654321

可以看出A类与B类的内部方法不一样，也就是说无法使用一致的接口对A，B公司进行同时访问，那么C类就应运而生。C类扮演的就是协议和接口转化的适配器的角色，将B公司人员接口封装，而对外接口形式与A公司人员接口一致，达到用A公司人员接口访问B公司人员信息的效果。

#### 模式优点

将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构 增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用 灵活性和扩展性非常好 类适配器模式：置换一些适配者的方法很方便 对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类

#### 模式缺点 类适配器模式：

(1) 一次最多只能适配一个适配者类，不能同时适配多个适配者；(2) 适配者类不能为最终类；(3) 目标抽象类只能为接口，不能为类 对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦

#### 模式适用环境

系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码 创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作

#### 另外：

适配器模式和装饰模式有一定的相似性，都起包装的作用，但二者本质上又是不同的，装饰模式的结果，是给一个对象增加了一些额外的职责，而适配器模式，则是将另一个对象进行了“伪装”。适配器可以认为是对现在业务的补偿式应用，所以，尽量不要在设计阶段使用适配器模式，在两个系统需要兼容时可以考虑使用适配器模式。





### 2、桥接模式

#### 说明：

有些类在功能设计上要求，自身包含两个或两个以上变化的因素，即该类在二维或者多维上变化。现有一杯咖啡，咖啡杯的大小和是否加奶为两个变化因素，使得这杯咖啡在这两个维度上发生变化，也就是可以产生四个类：小杯不加奶，小杯加奶，大杯不加奶，大杯加奶。这样的话如果说在给咖啡多几个变化因素如：加糖，是否加热等，那么就会有呈指数增长个数的子类产生。但是我们可以从另一个角度考虑。这四个类其实是两个角色的组合，行为和抽象，抽象为大杯小杯，行为为加奶与否。这种分离抽象与行为的方法就是桥接模式。

桥接模式：将抽象部分与它的`实现部分解耦`，使得两者都能够独立变化适应业务需求，或者说是两个部分中的任何一部分发生变化时都不会影响对方，”井水不犯河水"。桥接模式桥接模式又被称为柄体(Handle and Body)模式或接口(Interface)模式 用抽象关联取代了传统的多层继承 将类之间的静态继承关系转换为动态的对象组合关系,`两维度相分离，可以独立地变化`

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180602214514014-18364703.png)

```python
from abc import ABCMeta,abstractmethod

class Shape(metaclass=ABCMeta):
    def __init__(self,color):
        self.color = color

    @abstractmethod
    def draw(self):
        pass

class Color(metaclass=ABCMeta):
    @abstractmethod
    def paint(self,shape):
        pass

class Rectangle(Shape):
    name = "长方形"
    def draw(self):
        # 长方形逻辑
        self.color.paint(self)

class Red(Color):
    def paint(self,shape):
        print(f"红色的{shape.name}")


image = Rectangle(Red())
image.draw()
```

 

#### 桥接模式的结构

桥接模式包含以下4个角色： Abstraction（抽象类） RefinedAbstraction（扩充抽象类） Implementor（实现类接口） ConcreteImplementor（具体实现类）

##### 实例：

在一个画图程序中，常会见到这样的情况：有一些预设的图形，如矩形、圆形等，还有一个对象-画笔，调节画笔的类型（如画笔还是画刷，还是毛笔效果等）并设定参数（如颜色、线宽等），选定图形，就可以在画布上画出想要的图形了。要实现以上需求，先从最抽象的元素开始设计，即形状和画笔

```python
class Shape:
    name=""
    param=""
    def __init__(self,*param):
        pass
    def getName(self):
        return self.name
    def getParam(self):
        return self.name,self.param

class Pen:
    shape=""
    type=""
    def __init__(self,shape):
        self.shape=shape
    def draw(self):
        pass


#形状对象和画笔对象是最为抽象的形式。接下来，构造多个形状，如矩形和圆形
class Rectangle(Shape):
    def __init__(self,long,width):
        self.name="Rectangle"
        self.param="Long:%s Width:%s"%(long,width)
        print("Create a rectangle:%s"%self.param)
class Circle(Shape):
    def __init__(self,radius):
        self.name="Circle"
        self.param="Radius:%s"%radius
        print("Create a circle:%s"%self.param)

#紧接着是构造多种画笔，如普通画笔和画刷：
class NormalPen(Pen):
    def __init__(self,shape):
        Pen.__init__(self,shape)
        self.type="Normal Line"
    def draw(self):
        print("DRAWING %s:%s----PARAMS:%s"%(self.type,self.shape.getName(),self.shape.getParam()))
class BrushPen(Pen):
    def __init__(self,shape):
        Pen.__init__(self,shape)
        self.type="Brush Line"
    def draw(self):
        print("DRAWING %s:%s----PARAMS:%s" % (self.type,self.shape.getName(), self.shape.getParam()))

#业务中的逻辑如下：
if __name__=="__main__":
    normal_pen=NormalPen(Rectangle("20cm","10cm"))
    brush_pen=BrushPen(Circle("15cm"))
    normal_pen.draw()
    brush_pen.draw()
```



打印结果：

Create a rectangle:Long:20cm Width:10cm
Create a circle:Radius:15cm
DRAWING Normal Line:Rectangle----PARAMS:('Rectangle', 'Long:20cm Width:10cm')
DRAWING Brush Line:Circle----PARAMS:('Circle', 'Radius:15cm')

对象形状和画笔是最为抽象的形式。形状包括矩形和圆形，又可以在后期业务需求中扩展正方形，三角形等，画笔也可以由普通画笔和画刷扩展羽毛笔，水笔等多个类，很好的支持了开放封闭原则。最重要的是对象形状和画笔这两个部分可以独立变化却不受彼此的影响。

 

#### 模式优点

分离抽象接口及其实现部分 可以取代多层继承方案，极大地减少了子类的个数 提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则

#### 模式缺点

会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程 正确识别出系统中两个独立变化的维度并不是一件容易的事情

#### 模式适用环境

需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系 抽象部分和实现部分可以以继承的方式独立扩展而互不影响 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展 不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统





### 3、组合模式

#### 说明：

组合模式主要用来处理一类具有“容器特征”的对象——它们即充当对象又可以作为容器包含其他多个对象。组合模式对“容器特征”的对象和单个对象一视同仁。例如在计算机处理算术表达式的时候，算术表达式包括操作数，操作符和另一个操作数。操作数可以是一个数字也可以是另一个表达式。这样7+8和（2+3）+（4*6）都是合法的表达式，计算机先将（2+3）+（4*6）分解为（2+3）和（4*6）在对上述两个操作数进行进一步分解。

组合模式也叫作部分-整体模式，其定义如下：将对象组合成树形结构以表示`“部分”和“整体”的层次结构`，使得用户对单个对象和组合对象的使用具有一致性。

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180603120528760-1606838130.png)

 

```python
from abc import ABCMeta,abstractmethod

# 抽象组件
class Graphic(metaclass=ABCMeta):
    @abstractmethod
    def draw(self):
        pass

# 叶子组件
class Point(Graphic):
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"点{self.x,self.y}"

    def draw(self):
        print(str(self))

# 叶子组件
class Line(Graphic):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2

    def __str__(self):
        return f"线[{str(self.p1), str(self.p2)}]"

    def draw(self):
        print(str(self))

# 复合组件
class Picture(Graphic):
    def __init__(self,iterable):
        self.children = []
        for g in iterable:
            self.add(g)

    def add(self, graphic):
        self.children.append(graphic)

    def draw(self):
        print("-----复合图形-----")
        for g in self.children:
            g.draw()
        print("-----复合图形-----")


# l = Point(1,2)
l1 = Line(Point(1,2),Point(3,4))
l2 = Line(Point(5,6),Point(7,8))
pic1 = Picture([l1,l2])

l3 = Line(Point(9,10),Point(11,12))
l4 = Line(Point(13,14),Point(15,16))
pic2 = Picture([l3,l4])

pic3 = Picture([pic1,pic2])
pic3.draw()

```



#### 实例：

每一个公司都有自己的组织结构，越是大型的企业，其组织结构就会越复杂。大多数情况下，公司喜欢用“树形”结构来组织复杂的公司人事关系和公司间的结构关系。一般情况下，根结点代表公司的最高行政权利单位，分支节点表示一个个部门，而叶子结点则会用来代表每一个员工。每一个结点的子树，表示该结点代表的部门所管理的单位。假设一个具有HR部门，财务部门和研发部门，同时在全国有分支公司的总公司，其公司结构，可以表示成如下逻辑：

```python
class Company:
    name = ''
    def __init__(self, name):
        self.name = name
    def add(self, company):
        pass
    def remove(self, company):
        pass
    def display(self, depth):
        pass
    def listDuty(self):
        pass

class ConcreteCompany(Company):
    childrenCompany = None
    def __init__(self, name):
        Company.__init__(self,name)
        self.childrenCompany = []
    def add(self, company):
        self.childrenCompany.append(company)
    def remove(self, company):
        self.childrenCompany.remove(company)
    def display(self, depth):
        print('-'*depth + self.name)
        for component in self.childrenCompany:
            component.display(depth+1)
    def listDuty(self):
        for component in self.childrenCompany:
            component.listDuty()
class HRDepartment(Company):
    def __init__(self, name):
         Company.__init__(self,name)
    def display(self, depth):
        print('-'*depth + self.name)
    def listDuty(self): #履行职责
        print('%s\t Enrolling & Transfering management.' % self.name)

class FinanceDepartment(Company):
    def __init__(self, name):
        Company.__init__(self,name)
    def display(self, depth):
        print("-" * depth + self.name)
    def listDuty(self): #履行职责
        print('%s\tFinance Management.'%self.name)

class RdDepartment(Company):
    def __init__(self,name):
        Company.__init__(self,name)
    def display(self, depth):
        print("-"*depth+self.name)
    def listDuty(self):
        print("%s\tResearch & Development."% self.name)"""在该例中，公司结构抽象仅考虑公司（ConcreteCompany）和部门（Department），公司有子公司的可能性，公司也有自己的部门，部门是最终的叶子结点。假设总公司下设东边的分公司一个，东边的分公司下设东北公司和东南公司，显示公司层级，并罗列这些的公司中各部门的职责，可以构建如下业务场景："""

if __name__=="__main__":
    root = ConcreteCompany('HeadQuarter')
    root.add(HRDepartment('HQ HR'))
    root.add(FinanceDepartment('HQ Finance'))
    root.add(RdDepartment("HQ R&D"))

    comp = ConcreteCompany('East Branch')
    comp.add(HRDepartment('East.Br HR'))
    comp.add(FinanceDepartment('East.Br Finance'))
    comp.add(RdDepartment("East.Br R&D"))
    root.add(comp)

    comp1 = ConcreteCompany('Northast Branch')
    comp1.add(HRDepartment('Northeast.Br HR'))
    comp1.add(FinanceDepartment('Northeast.Br Finance'))
    comp1.add(RdDepartment("Northeast.Br R&D"))
    comp.add(comp1)

    comp2 = ConcreteCompany('Southeast Branch')
    comp2.add(HRDepartment('Southeast.Br HR'))
    comp2.add(FinanceDepartment('Southeast.Br Finance'))
    comp2.add(RdDepartment("Southeast.Br R&D"))
    comp.add(comp2)

    root.display(1)

    root.listDuty()
```



打印结果：

-HeadQuarter
--HQ HR
--HQ Finance
--HQ R&D
--East Branch
---East.Br HR
---East.Br Finance
---East.Br R&D
---Northast Branch
----Northeast.Br HR
----Northeast.Br Finance
----Northeast.Br R&D
---Southeast Branch
----Southeast.Br HR
----Southeast.Br Finance
----Southeast.Br R&D
HQ HR Enrolling & Transfering management.
HQ Finance Finance Management.
HQ R&D Research & Development.
East.Br HR Enrolling & Transfering management.
East.Br Finance Finance Management.
East.Br R&D Research & Development.
Northeast.Br HR Enrolling & Transfering management.
Northeast.Br Finance Finance Management.
Northeast.Br R&D Research & Development.
Southeast.Br HR Enrolling & Transfering management.
Southeast.Br Finance Finance Management.
Southeast.Br R&D Research & Development.

 

#### 优点：

1、节点增加和减少是非常自由和方便的，这也是树形结构的一大特点；
2、所有节点，不管是分支节点还是叶子结点，不管是调用一个结点，还是调用一个结点群，都是非常方便的。

#### 使用场景：

1、希望把对象表示分成部分-整体层次结构时

2、希望用户忽略组合对象与单个对象的不同，用户将统一的使用组合结构中的所有对象。

#### 缺点

组合模式在定义树叶和树枝时直接使用了实现类，不符合面向对象接口编程。与依赖倒置原则冲突。



### 4、外观模式

外观模式又叫做门面模式。在面向对象程序设计中，解耦是一种推崇的理念。但事实上由于某些系统中过于复杂，从而增加了客户端与子系统之间的耦合度。例如：在家观看多媒体影院时，更希望按下一个按钮就能实现影碟机，电视，音响的协同工作，而不是说每个机器都要操作一遍。这种情况下可以采用外观模式，即引入一个类对子系统进行包装，让客户端与其进行交互。

外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。`为子系统的一组接口提供一个一致的界面，定义了一个高岑接口，让子系统更容易使用`

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180602213151322-1823109579.png)

```python
# 子系统类
class Cpu:
    def run(self):
        print("CPU运行")

    def stop(self):
        print("CPU停止")


class Memory:
    def run(self):
        print("内存运行")

    def stop(self):
        print("内存停止")


class Disk:
    def run(self):
        print("磁盘运行")

    def stop(self):
        print("磁盘停止")

# 外观
class Computer:
    def __init__(self):
        self.cpu = Cpu()
        self.memory = Memory()
        self.disk = Disk()

    def run(self):
        self.cpu.run()
        self.memory.run()
        self.disk.run()

    def stop(self):
        self.cpu.stop()
        self.memory.stop()
        self.disk.stop()

if __name__ == '__main__':
    computer = Computer()
    computer.run()
```

 

#### 结构说明：

外观模式包含如下角色： Facade: 外观角色 SubSystem:子系统角色

#### 实例：

假设有一组火警报警系统，由三个子元件构成：一个警报器，一个喷水器，一个自动拨打电话的装置。



```python
#当火警发生时，先警报器响起警报，喷水器开始喷水，最后开始拨打火警电话
class AlarmSensor:
    def run(self):
        print "Alarm Ring..."
class WaterSprinker:
    def run(self):
        print "Spray Water..."
class EmergencyDialer:
    def run(self):
        print "Dial 119..."

#业务代码
if __name__=="__main__":
    alarm_sensor=AlarmSensor()
    water_sprinker=WaterSprinker()
    emergency_dialer=EmergencyDialer()
    alarm_sensor.run()
    water_sprinker.run()
    emergency_dialer.run()
```



打印结果为：

Alarm Ring...
Spray Water...
Dial 119...

虽然也完成了业务需求，但是明显的是客户的负担较重，客户端与子系统的耦合度太大。如果在多个业务场景中需要启动三个部件，复制粘贴当仍然可以解决。但是减少重复代码是应该会被很轻易想到的方法。这样，需要将其进行封装，在设计模式中，被封装成的新对象，叫做外观。



```
class AlarmSensor:
    def run(self):
        print("Alarm Ring...")
class WaterSprinker:
    def run(self):
        print("Spray Water...")
class EmergencyDialer:
    def run(self):
        print("Dial 119...")

class EmergencyFacade:
    """
    外观类中封装了对子系统的操作
    """
    def __init__(self):
        self.alarm_sensor=AlarmSensor()
        self.water_sprinker=WaterSprinker()
        self.emergency_dialer=EmergencyDialer()
    def runAll(self):
        self.alarm_sensor.run()
        self.water_sprinker.run()
        self.emergency_dialer.run()

if __name__=="__main__":
    emergency_facade=EmergencyFacade()
    emergency_facade.runAll()
```



打印结果：

Alarm Ring...
Spray Water...
Dial 119...

完成了业务需求。

#### 模式分析

根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。

外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 外观模式的目的在于降低系统的复杂程度。 外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。

#### 优点：

主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；

#### 缺点：

其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

#### 使用情况：

适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。



### 5、代理模式

#### 说明：

模式动机 通过引入一个新的对象（如小图片和远程代理对象）来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。

常见的有：分析 代购商品：顾客 ->代购网站 -> 商品 ，  软件开发：客户端 -> 代理对象-> 真实对象。客户端通过一个代理对象来实现对真是对象的访问。

`远程代理`

`虚代理`

`保护代理`

代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。

代理模式的定义 引入一个新的代理对象 代理对象在客户端对象和目标对象之间起到中介的作用 去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务，`被高层代码统一的使用`

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180603111520653-2042580914.png)

 

```python
from abc import ABCMeta, abstractmethod


class Subject(metaclass=ABCMeta):
    @abstractmethod
    def get_content(self):
        pass

    @abstractmethod
    def set_content(self, content):
        pass


class RealSubject(Subject):
    def __init__(self, filename):
        self.filename = filename
        print("读取文件内容")
        f = open(filename, 'r')
        self.content = f.read()
        f.close()

    def get_content(self):
        return self.content

    def set_content(self, content):
        f = open(self.filename, 'w', encoding='utf-8')
        f.write()
        f.close()

# 虚代理
class VirtualProxy(Subject):
    def __init__(self, filename):
        self.filename = filename
        self.sub = None

    def get_content(self):
        if not self.sub:
            self.sub = RealSubject(self.filename)
        return self.sub.get_content()

    def set_content(self, content):
        if not self.sub:
            self.sub = RealSubject(self.filename)
        return self.sub.set_content()

# 保护代理
class ProtectProxy(Subject):
    def __init__(self, filename):
        self.sub = RealSubject(filename)

    def get_content(self):
        return self.sub.get_content()

    def set_content(self, content):
        raise PermissionError("无写入权限")


subj = ProtectProxy("text.txt")
print(subj.get_content())
subj.set_content("777")

```



#### 代理模式的结构

代理模式包含以下3个角色： Subject（抽象主题角色） Proxy（代理主题角色） RealSubject（真实主题角色）

实例：



```python
#构建一个服务器，该服务器接受如下格式数据，addr代表地址，content代表接收的信息内容
info_struct=dict()
info_struct["addr"]=10000
info_struct["content"]=""
class Server:
    content=""
    def recv(self,info):
        pass
    def send(self,info):
        pass
    def show(self):
        pass
class infoServer(Server):
    def recv(self,info):
        self.content=info
        return "recv OK!"
    def send(self,info):
        pass
    def show(self):
        print("SHOW:%s"%self.content)

"""
infoServer有接收和发送的功能，发送功能由于暂时用不到，保留。
另外新加一个接口show，用来展示服务器接收的内容。
接收的数据格式必须如info_struct所示，服务器仅接受info_struct的content字段。
那么，如何给这个服务器设置一个白名单，使得只有白名单里的地址可以访问服务器呢？
修改Server结构是个方法，但这显然不符合软件设计原则中的单一职责原则。
在此基础之上，使用代理，是个不错的方法。代理配置如下
"""


class serverProxy:
    pass
class infoServerProxy(serverProxy):
    server=""
    def __init__(self,server):
        self.server=server
    def recv(self,info):
        return self.server.recv(info)
    def show(self):
        self.server.show()

class whiteInfoServerProxy(infoServerProxy):
    white_list=[]
    def recv(self,info):
        try:
            assert type(info)==dict
        except:
            return "info structure is not correct"
        addr=info.get("addr",0)
        if not addr in self.white_list:
            return "Your address is not in the white list."
        else:
            content=info.get("content","")
            return self.server.recv(content)
    def addWhite(self,addr):
        self.white_list.append(addr)
    def rmvWhite(self,addr):
        self.white_list.remove(addr)
    def clearWhite(self):
        self.white_list=[]

"""
代理中有一个server字段，控制代理的服务器对象，infoServerProxy充当Server的直接接口代理，
而whiteInfoServerProxy直接继承了infoServerProxy对象，同时加入了white_list和对白名单的操作。
这样，在场景中通过对白名单代理的访问，就可以实现服务器的白名单访问了。
"""

if  __name__=="__main__":
    info_struct = dict()
    info_struct["addr"] = 10010
    info_struct["content"] = "Hello World!"
    info_server = infoServer()
    info_server_proxy = whiteInfoServerProxy(info_server)
    print(info_server_proxy.recv(info_struct))
    info_server_proxy.show()
    info_server_proxy.addWhite(10010)
    print(info_server_proxy.recv(info_struct))
    info_server_proxy.show()
```



打印结果：

Your address is not in the white list.
SHOW:
recv OK!
SHOW:Hello World!

 

#### 几种常见的代理模式

远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使(Ambassador)

虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建

保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限

缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果

智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等

#### 模式优点

能够协调调用者和被调用者，在一定程度上降低了系统的耦合度 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性

#### 模式缺点

由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理） 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理）

#### 模式适用环境

当客户端对象需要访问远程主机中的对象时可以使用远程代理 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理



## 三、行为型模式

### 1、责任链模式

当你作为一名coder已经快三十却还还没有女朋友，家中父母已经着急万分，此时要求你回家相亲，你嘴上说不要，我还年轻，还要为事业打拼，但是摸着头顶上日渐稀少的毛发，身体也很诚实，早早的写好了假条。此时要找领导请假，但是又不知道找哪个靠谱的领导。简言之，提交请求的对象并不明确知道谁是最终响应请求的对象。这样的话就存在了两种可能解决，广播的方式进行搜索命令对象还是让每个命令对象都指定某个处理对象。前者存在不确定性，后者则会造成处理对象之间的强耦合。

如果应用责任链模式解决问题是，你若想要请3天以内（包括3天的假），只需要直属经理批准就可以了；如果想请3-7天，不仅需要直属经理批准，部门经理需要最终批准；如果请假大于7天，不光要前两个经理批准，也需要总经理最终批准。“假条”在三个经理间是单向传递关系，像一条链条一样，因而，我们可以用一条“链”把他们进行有序连接。

责任链模式的定义如下：使多个对象都有机会处理请求，从而避免发送者和接收者的耦合关系。`将对象连成链并沿着这条链传递请求直到被处理`。

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180603210613693-552625206.png)

 

```python
from abc import ABCMeta, abstractmethod


class Handler(metaclass=ABCMeta):
    @abstractmethod
    def handler_leave(self, day):
        pass


class Seniormanager(Handler):

    def handler_leave(self, day):
        if day <= 10:
            print(f"总经理同意请假{day}天")
        else:
            print("辞职吧")


class Departmentmanager(Handler):
    def __init__(self):
        self.next = Seniormanager()
    def handler_leave(self, day):
        if day <= 5:
            print(f"部门经理同意请假{day}天")
        else:
            print("部门经理权限不足")
            self.next.handler_leave(day)


class Projectmanager(Handler):
    def __init__(self):
        self.next = Departmentmanager()
    def handler_leave(self, day):
        if day<=3:
            print(f"项目经理同意请假{day}天")
        else:
            print("项目经理权限不足")
            self.next.handler_leave(day)



if __name__ == '__main__':
    day = 78
    Projectmanager().handler_leave(day)


```



### 结构：

抽象处理者，具体处理者。

### 实例：

根据上述说明中的请假实例



```python
#构造抽象经理类和各个层级的经理类：
class manager():
    successor = None
    name = ''
    def __init__(self, name):
        self.name = name
    def setSuccessor(self, successor):
        self.successor = successor
    def handleRequest(self, request):
        pass

class lineManager(manager):
    def handleRequest(self, request):
        if request.requestType == 'DaysOff' and request.number <= 3:
            print('%s:%s Num:%d Accepted OVER' % (self.name, request.requestContent, request.number))
        else:
            print('%s:%s Num:%d Accepted CONTINUE' % (self.name, request.requestContent, request.number))
            if self.successor != None:
                self.successor.handleRequest(request)

class departmentManager(manager):
    def handleRequest(self, request):
        if request.requestType == 'DaysOff' and request.number <= 7:
            print('%s:%s Num:%d Accepted OVER' % (self.name, request.requestContent, request.number))
        else:
            print('%s:%s Num:%d Accepted CONTINUE' % (self.name, request.requestContent, request.number))
            if self.successor != None:
                self.successor.handleRequest(request)

class generalManager(manager):
    def handleRequest(self, request):
        if request.requestType == 'DaysOff':
            print('%s:%s Num:%d Accepted OVER' % (self.name, request.requestContent, request.number))

class request():
    requestType = ''
    requestContent = ''
    number = 0

#request类封装了假期请求。在具体的经理类中，可以通过setSuccessor接口来构建“责任链”，并在handleRequest接口中实现逻辑。
# 场景类中实现如下
if  __name__=="__main__":
    line_manager = lineManager('LINE MANAGER')
    department_manager = departmentManager('DEPARTMENT MANAGER')
    general_manager = generalManager('GENERAL MANAGER')

    line_manager.setSuccessor(department_manager)
    department_manager.setSuccessor(general_manager)

    req = request()
    req.requestType = 'DaysOff'
    req.requestContent = 'Ask 1 day off'
    req.number = 1
    line_manager.handleRequest(req)

    req.requestType = 'DaysOff'
    req.requestContent = 'Ask 5 days off'
    req.number = 5
    line_manager.handleRequest(req)

    req.requestType = 'DaysOff'
    req.requestContent = 'Ask 10 days off'
    req.number = 10
    line_manager.handleRequest(req)
```



打印结果：

LINE MANAGER:Ask 1 day off Num:1 Accepted OVER
LINE MANAGER:Ask 5 days off Num:5 Accepted CONTINUE
DEPARTMENT MANAGER:Ask 5 days off Num:5 Accepted OVER
LINE MANAGER:Ask 10 days off Num:10 Accepted CONTINUE
DEPARTMENT MANAGER:Ask 10 days off Num:10 Accepted CONTINUE
GENERAL MANAGER:Ask 10 days off Num:10 Accepted OVER

### 优点：

降低了请求发出者和请求处理者之间的耦合。增强了对象指派职责的灵活性。

### 缺点：

一方面责任链过长会出现性能问题，另一方面，如果一个情求没有被正确处理也就是说不存在一个可以处理该请求的命令接收者而反复执行。

### 适用环境：

有多个对象可以处理一个请求，那个对象处理该请求会在运行时刻自动确定。若一个请求可能由一个对请求有链式优先级的处理群所处理时，可以考虑责任链模式。



### 2、观察者模式

### 说明：

存在这样的一种情况：公司领导再开例会那天临时有事，他让秘书给所有会上员工群发了一封邮件，通知大家会议取消，员工们收到邮件之后得知会议取消便继续回到各自岗位开始工作。这其中就包含了一种隐含地思想就是：领导与员工们之间的“一对多的通知依赖关系”。即一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动。

观察者模式：

定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。发生改变的对象称为观察目标，被通知的对象称为观察者 。一个观察目标可以对应多个观察者

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180603170615296-480101221.png)

```python
from abc import ABCMeta, abstractmethod


class Observeabs(metaclass=ABCMeta):    # 抽象订阅者

    @abstractmethod
    def update(self, notice):  # notice是Noticeabs类的一个对象
        pass


class Noticeabs:                        # 抽象发布者
    def __init__(self):
        self.observers = []

    def attach(self, user):
        self.observers.append(user)

    def detach(self, user):
        self.observers.remove(user)

    def notify(self):       # 推送
        for user in self.observers:
            user.update(self)


class Company(Noticeabs):               # 实际发布者
    def __init__(self,company_info = None):
        super().__init__()
        self.__company_info = company_info

    @property
    def company_info(self):
        return self.__company_info

    @company_info.setter
    def company_info(self,info):
        self.__company_info = info
        self.notify()


class Staff(Observeabs):
    def __init__(self):
        self.company_info = None

    def update(self, notice):
        self.company_info = notice.company_info


if __name__ == '__main__':
    notice = Company("初始化消息")
    staff1 = Staff()
    staff2 = Staff()
    notice.attach(staff1)
    notice.attach(staff2)
    notice.company_info = "打得不错"
    print(staff1.company_info)
    print(staff2.company_info)


    notice.detach(staff1)
    notice.company_info = "7"
    print(staff1.company_info)
    print(staff2.company_info)
```

 

### 观察者模式的结构

观察者模式包含以下4个角色： Subject（目标） ConcreteSubject（具体目标） Observer（观察者） ConcreteObserver（具体观察者）

### 实例：



```python
"""
在门面模式中，我们提到过火警报警器。在当时，我们关注的是通过封装减少代码重复。
而今天，我们将从业务流程的实现角度，来再次实现该火警报警器。
"""

class AlarmSensor:
    def run(self):
        print("Alarm Ring...")
class WaterSprinker:
    def run(self):
        print("Spray Water...")
class EmergencyDialer:
    def run(self):
        print("Dial 119...")

"""
以上是门面模式中的三个传感器类的结构。仔细分析业务，报警器、洒水器、拨号器都是“观察”烟雾传感器的情况来做反应的。因而，他们三个都是观察者，而烟雾传感器则是被观察对象了。根据分析，将三个类提取共性，泛化出“观察者”类，并构造被观察者。
观察者如下：
"""

class Observer:
    def update(self):
        pass
class AlarmSensor(Observer):
    def update(self,action):
        print("Alarm Got: %s" % action)
        self.runAlarm()
    def runAlarm(self):
        print("Alarm Ring...")
class WaterSprinker(Observer):
    def update(self,action):
        print("Sprinker Got: %s" % action)
        self.runSprinker()
    def runSprinker(self):
        print("Spray Water...")
class EmergencyDialer(Observer):
    def update(self,action):
        print("Dialer Got: %s"%action)
        self.runDialer()
    def runDialer(self):
        print("Dial 119...")

"""
观察者中定义了update接口，如果被观察者状态比较多，或者每个具体的观察者方法比较多，可以通过update传参数进行更丰富的控制。
下面构造被观察者。
"""

class Observed:
    observers=[]
    action=""
    def addObserver(self,observer):
        self.observers.append(observer)
    def notifyAll(self):
        for obs in self.observers:
            obs.update(self.action)
class smokeSensor(Observed):
    def setAction(self,action):
        self.action=action
    def isFire(self):
        return True

"""
被观察者中首先将观察对象加入到观察者数组中，若发生情况，则通过notifyAll通知各观察者。
业务代码如下：
"""

if __name__=="__main__":
    alarm=AlarmSensor()
    sprinker=WaterSprinker()
    dialer=EmergencyDialer()

    smoke_sensor=smokeSensor()
    smoke_sensor.addObserver(alarm)
    smoke_sensor.addObserver(sprinker)
    smoke_sensor.addObserver(dialer)

    if smoke_sensor.isFire():
        smoke_sensor.setAction("On Fire!")
        smoke_sensor.notifyAll()
```



打印结果：

Alarm Got: On Fire!
Alarm Ring...
Sprinker Got: On Fire!
Spray Water...
Dialer Got: On Fire!
Dial 119...

### 模式优点

可以实现表示层和数据逻辑层的分离 在观察目标和观察者之间建立一个抽象的耦合 支持广播通信，简化了一对多系统设计的难度 符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便

### 模式缺点

将所有的观察者都通知到会花费很多时间 如果存在循环依赖时可能导致系统崩溃 没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化

### 模式适用环境

一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用 一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁 需要在系统中创建一个触发链



### 3、策略模式

### 说明：

策略指的就是为了达到某一目的而采取的手段或者方法。为了实现软件设计咪表，对象可能会用到多种多样的算法。这些算法甚至会经常改变。如果将这些算法都硬编码到对象中，将会使得对象本身变得臃肿不堪，而且有时候支持不同的算法也是一个性能负担。策略模式很好的实现了在运行时根据需要透明的更改对象的算法和将算法与本身对象解耦，从而避免出现上述两个问题。

因此策略模式可以定义为：　定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户变化。每一个封装算法的类称之为策略(Strategy)类，策略模式提供了一种可插入式(Pluggable)算法的实现方案

![img](C:\Users\98680\Desktop\学习笔记\设计模式\img\1367382-20180603155719048-1333931056.png)

 

```python
# @Time :2024/4/20 13:38
from abc import ABCMeta, abstractmethod


class Strategy(metaclass=ABCMeta):
    @abstractmethod
    def execute(self, data):
        pass


class Faststrategy(Strategy):
    def execute(self, data):
        print(f"使用较快的策略执行{data}")


class Slowstrategy(Strategy):
    def execute(self, data):
        print(f"使用较慢的策略执行{data}")


class Context:
    def __init__(self, strategy, data):
        self.strategy = strategy
        self.data = data

    def set_strategy(self, strategy):
        self.strategy = strategy

    def do_strategy(self):
        self.strategy.execute(self.data)


data = "[77777]"
c1 = Faststrategy()
c2 = Slowstrategy()

context = Context(c1, data)
context.do_strategy()

context.set_strategy(c2)
context.do_strategy()
```



### 策略模式的结构

策略模式包含以下3个角色： Context（环境类） Strategy（抽象策略类） ConcreteStrategy（具体策略类）

### 实例：

假设某司维护着一些客户资料，需要在该司有新产品上市或者举行新活动时通知客户。现通知客户的方式有两种：短信通知、邮件通知。应如何设计该系统的客户通知部分？为解决该问题，我们先构造客户类，包括客户常用的联系方式和基本信息，同时也包括要发送的内容。



```
class customer:
    customer_name=""
    snd_way=""
    info=""
    phone=""
    email=""
    def setPhone(self,phone):
        self.phone=phone
    def setEmail(self,mail):
        self.email=mail
    def getPhone(self):
        return self.phone
    def getEmail(self):
        return self.email
    def setInfo(self,info):
        self.info=info
    def setName(self,name):
        self.customer_name=name
    def setBrdWay(self,snd_way):
        self.snd_way=snd_way
    def sndMsg(self):
        self.snd_way.send(self.info)#snd_way向客户发送信息的方式，该方式置为可设，即可根据业务来进行策略的选择。#发送方式构建如下：
class msgSender:
    dst_code=""
    def setCode(self,code):
        self.dst_code=code
    def send(self,info):
        pass

class emailSender(msgSender):
    def send(self,info):
        print("EMAIL_ADDRESS:%s EMAIL:%s"%(self.dst_code,info))

class textSender(msgSender):
    def send(self,info):
        print("TEXT_CODE:%s EMAIL:%s"%(self.dst_code,info))
#业务场景中将发送方式作为策略
if  __name__=="__main__":
    customer_x=customer()
    customer_x.setName("CUSTOMER_X")
    customer_x.setPhone("10023456789")
    customer_x.setEmail("customer_x@xmail.com")
    customer_x.setInfo("Welcome to our new party!")
    text_sender=textSender()
    text_sender.setCode(customer_x.getPhone())
    customer_x.setBrdWay(text_sender)
    customer_x.sndMsg()
    mail_sender=emailSender()
    mail_sender.setCode(customer_x.getEmail())
    customer_x.setBrdWay(mail_sender)
    customer_x.sndMsg()
```



打印结果

TEXT_CODE:10023456789 EMAIL:Welcome to our new party!
EMAIL_ADDRESS:customer_x@xmail.com EMAIL:Welcome to our new party!

 

### 模式优点

提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为 提供了管理相关的算法族的办法 提供了一种可以替换继承关系的办法 可以避免多重条件选择语句 提供了一种算法的复用机制，不同的环境类可以方便地复用策略类

### 模式缺点

客户端必须知道所有的策略类，并自行决定使用哪一个策略类 将造成系统产生很多具体策略类 无法同时在客户端使用多个策略类

### 模式适用环境

一个系统需要动态地在几种算法中选择一种 避免使用难以维护的多重条件选择语句 不希望客户端知道复杂的、与算法相关的数据结构，提高算法的保密性与安全性

另外：

仔细比较一下桥接模式和策略模式，如果把策略模式的Context设计成抽象类和实现类的方式，那么策略模式和桥接模式就可以划等号了。从类图看上去，桥接模式比策略模式多了对一种角色（抽象角色）的抽象。二者结构的高度同构，也只能让我们从使用意图上去区分两种模式：桥接模式解决抽象角色和实现角色都可以扩展的问题；而策略模式解决算法切换和扩展的问题。



### 4、模板方法模式

模板方法模式时行为模式中比较简单的设计模式之一。模板方法关注这样的一类行为：该类行为在执行过程中拥有大致相同的动作次序，只是动作在实现的具体细节上有所差异。例如：泡茶和泡咖啡，泡茶：把水煮沸，沸水加入茶叶，把倒进杯子。泡咖啡：把水煮沸，用沸水冲咖啡粉，把咖啡倒进杯子。这样看来泡茶和泡咖啡的三个步骤基本相似。我们可以报这一类行为抽象成一个算法，并将其中的动作序列按1其先后顺序也抽象出来作为该算法的一些步骤。至于这些步骤的实现细节，则有算法的子类去实现。

模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。

模板方法模式 是一种基于继承的代码复用技术 ，将一些复杂流程的实现步骤封装在一系列基本方法中 ，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。

![image-20240421152158317](C:\Users\98680\Desktop\学习笔记\设计模式\img\image-20240421152158317.png)

```python
# @Time :2024/4/21 16:12

from abc import ABCMeta, abstractmethod
from time import sleep


class Window(metaclass=ABCMeta):

    @abstractmethod
    def start(self):
        pass

    @abstractmethod
    def repaint(self):
        pass

    @abstractmethod
    def stop(self):
        pass

    def run(self):
        self.start()
        while True:
            try:
                self.repaint()
                sleep(1)
            except KeyboardInterrupt:
                break
        self.stop()


class Mywindow(Window):
    def __init__(self, msg):
        self.msg = msg

    def start(self):
        print("start")

    def stop(self):
        print("stop")

    def repaint(self):
        print(self.msg)


Mywindow("打开窗口").run()

```



###  

### 模板方法模式的结构

模板方法模式包含以下两个角色： AbstractClass（抽象类） ConcreteClass（具体子类）

### 模板方法模式的实现：

模板方法 (Template Method)

基本方法 (Primitive Method) ：1、抽象方法(Abstract Method)2、 具体方法(Concrete Method) 3、钩子方法(Hook Method) ：“挂钩”方法和空方法

### 实例：

投资股票是种常见的理财方式，我国股民越来越多，实时查询股票的需求也越来越大。今天，我们通过一个简单的股票查询客户端来认识一种简单的设计模式：模板模式。
根据股票代码来查询股价分为如下几个步骤：登录、设置股票代码、查询、展示。



```
#构造如下的虚拟股票查询器：
class StockQueryDevice():
    stock_code="0"
    stock_price=0.0
    def login(self,usr,pwd):
        pass
    def setCode(self,code):
        self.stock_code=code
    def queryPrice(self):
        pass
    def showPrice(self):
        pass

#根据不同的查询机构和方式来通过继承的方式实现其的股票查询器类。
#WebA和WebB的查询器类可以构造如下：
class WebAStockQueryDevice(StockQueryDevice):
    def login(self,usr,pwd):
        if usr=="myStockA" and pwd=="myPwdA":
            print "Web A:Login OK... user:%s pwd:%s"%(usr,pwd)
            return True
        else:
            print "Web A:Login ERROR... user:%s pwd:%s"%(usr,pwd)
            return False
    def queryPrice(self):
        print "Web A Querying...code:%s "%self.stock_code
        self.stock_price=20.00
    def showPrice(self):
        print "Web A Stock Price...code:%s price:%s"%(self.stock_code,self.stock_price)
class WebBStockQueryDevice(StockQueryDevice):
    def login(self,usr,pwd):
        if usr=="myStockB" and pwd=="myPwdB":
            print "Web B:Login OK... user:%s pwd:%s"%(usr,pwd)
            return True
        else:
            print "Web B:Login ERROR... user:%s pwd:%s"%(usr,pwd)
            return False
    def queryPrice(self):
        print "Web B Querying...code:%s "%self.stock_code
        self.stock_price=30.00
    def showPrice(self):
        print "Web B Stock Price...code:%s price:%s"%(self.stock_code,self.stock_price)

#在场景中，想要在网站A上查询股票
if  __name__=="__main__":
    web_a_query_dev=WebAStockQueryDevice()
    web_a_query_dev.login("myStockA","myPwdA")
    web_a_query_dev.setCode("12345")
    web_a_query_dev.queryPrice()
    web_a_query_dev.showPrice()
```



打印结果：

Web A:Login OK... user:myStockA pwd:myPwdA
Web A Querying...code:12345 
Web A Stock Price...code:12345 price:20.0

但是发现每次操作，都会调用登录，设置代码，查询，展示这几步，是不是有些繁琐？既然有些繁琐，何不将这几步过程封装成一个接口。由于各个子类中的操作过程基本满足这个流程，所以这个方法可以写在父类中。



```
class StockQueryDevice():
    stock_code="0"
    stock_price=0.0
    def login(self,usr,pwd):
        pass
    def setCode(self,code):
        self.stock_code=code
    def queryPrice(self):
        pass
    def showPrice(self):
        pass

    def operateQuery(self, usr, pwd, code):
        if not self.login(usr, pwd):
            return False
        self.setCode(code)
        self.queryPrice()
        self.showPrice()
        return True

class WebAStockQueryDevice(StockQueryDevice):
    def login(self,usr,pwd):
        if usr=="myStockA" and pwd=="myPwdA":
            print("Web A:Login OK... user:%s pwd:%s"%(usr,pwd))
            return True
        else:
            print("Web A:Login ERROR... user:%s pwd:%s"%(usr,pwd))
            return False
    def queryPrice(self):
        print("Web A Querying...code:%s "%self.stock_code)
        self.stock_price=20.00
    def showPrice(self):
        print("Web A Stock Price...code:%s price:%s"%(self.stock_code,self.stock_price))
class WebBStockQueryDevice(StockQueryDevice):
    def login(self,usr,pwd):
        if usr=="myStockB" and pwd=="myPwdB":
            print("Web B:Login OK... user:%s pwd:%s"%(usr,pwd))
            return True
        else:
            print("Web B:Login ERROR... user:%s pwd:%s"%(usr,pwd))
            return False
    def queryPrice(self):
        print("Web B Querying...code:%s "%self.stock_code)
        self.stock_price=30.00
    def showPrice(self):
        print("Web B Stock Price...code:%s price:%s"%(self.stock_code,self.stock_price))


if  __name__=="__main__":
    web_a_query_dev=WebAStockQueryDevice()
    web_a_query_dev.operateQuery("myStockA","myPwdA","12345")
```

[![复制代码](https://assets.cnblogs.com/images/copycode.gif)](javascript:void(0);)

打印结果相同：

Web A:Login OK... user:myStockA pwd:myPwdA
Web A Querying...code:12345
Web A Stock Price...code:12345 price:20.0

 

### 模式优点

在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序 。提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为。 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行 更换和增加新的子类很方便，符合单一职责原则和开闭原则

### 模式缺点

需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统会更加庞大，设计也会更加抽象（可结合桥接模式）

### 模式适用环境

一次性实现一个算法的不变部分，并将可变的行为留给子类来实现 。各子类中公共的行为应被提取出来，并集中到一个公共父类中，以避免代码重复。 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制

另外：

在模板方法模式中，子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，父类控制对子类的调用，这种机制被称为好莱坞原则(Hollywood Principle)，好莱坞原则的定义为：“不要给我们打电话，我们会给你打电话(Don‘t call us, we’ll call you)”。在模板方法模式中，好莱坞原则体现在：子类不需要调用父类，而通过父类来调用子类，将某些步骤的实现写在子类中，由父类来控制整个过程。
