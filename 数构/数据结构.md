





# 数据结构

​    

### 循环队列

##### 为空：队头==队尾  Q->front = Q->rear

##### 为满：(Q->rear+1)%M

##### 入队：Q->front == (Q->f+1)%M

##### 出队：Q->r == (Q->r+1)%M

##### 计算长度： 

(r - f  + M)% M



### 完全有向与完全无向的边数

##### 有向：(n-1) * n

##### 无向：(n-1) * n / 2



### 算法复杂度度的度量依据是？

运行该算法所需要的计算机资源的多少



### 树的 遍历

##### 前序：中左右 

##### 中序：左中右

##### 后序：左右中



### 算法的五个性质

**输入**、输出、确定性、可行性 、**有限性**



### 算法的三要素 

数据、控制、操作



### 队列与堆栈的进出规则

##### 队列：先进先出 FIFO

##### 堆栈：后进先出 LIFO



### 排序算法

##### 时间空间复杂度

合并排序：**空间复杂度最大**  稳定 

桶排序：**不进行比较**



时间复杂度：O(n^2)

插入排序：稳定

冒泡排序：稳定

选择排序：不稳定

 

时间复杂度：O(nlogn)

快速排序：不稳定	(分解、递归求解、合并)

堆排序：不稳定



##### 直接插入

![image-20221014144232919](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014144232919.png)

第一遍： 38 49 65 97 76 13 27 49‘

 

##### 选择排序

![image-20221014144559844](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014144559844.png)



##### 堆排序

![image-20221014145521835](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014145521835.png)



##### 冒泡排序

 ![image-20221014150051386](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014150051386.png)



##### 快速排序

![image-20221014150416914](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014150416914.png)

![image-20221014150528825](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014150528825.png)







### 最小支持(生成)树算法

##### Prim算法 ：选点

![image-20221014113102609](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014113102609.png)

##### Kruskal算法 ：选边 

![image-20221014113228879](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014113228879.png)



##### Dijkstra 算法：最短路径 

![image-20221014133750271](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014133750271.png)

![image-20221014134136376](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014134136376.png)



min-path[0,2] = (0,2) =10

min-path[0,3] = (0,2)  + (2,3) =10 + 15 =25

min-path[0,1] = (0,2) + (2,3) + (3,1)  =10 +15+20 = 45

min-path[0,4] = (0,4) =45



### 查找

##### 顺序查找平均次数：

(n+1)/2   O(n)

##### 二分查找平均次数：

log2  (n+1)  -1    O(logn)

##### 分块查找平均次数：

分 ：根号n   个块

 

##### 散列查找：

K1 /= K2,   H(K1) = H(K2)  **冲突**

K1 = K2  **同义词**



###### 除留余数法

H(k) = k % p  (p<=m) 取最大的**质数**

![image-20221014143119732](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014143119732.png)



###### 线性探查法

容易产生**堆积**，连续若干个被占用 

**填满程度**越高，越容易产生冲突





### AVL树

删除、查找、插入、增加所需时间：**O(logn)**





### 散列函数

k%p 

p<=表长的最大质数



### 深广度搜查策略相似的

##### 深度优先：前序遍历   堆栈 

##### 广度优先：层次遍历   队列







### 二元组

<a1,a2>:a1 -> a2

(a1,a2):a1 - a2



### 线性表

##### 移动次数

插入：n/2

删除：(n-1)/2



##### 插入运算

![image-20221011145927361](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221011145927361.png)



##### 删除运算

![image-20221011150238928](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221011150238928.png)

#####  



## 选择题

![image-20221011112044111](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221011112044111.png)

![image-20221011150549442](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221011150549442.png)

![image-20221012150948029](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221012150948029.png)

1.数据元素一般是由一个或者多个数据项组成

2.需要经常进行对最后一个节点附近的增删改查，最适合的是：**双向循环链表**





### 

##### 树形结构

###### 双亲表示法

![image-20221013105549862](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221013105549862.png)

快速找到双亲



###### 多重链表表示法

![image-20221012153756412](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221012153756412.png)



###### 左儿子右兄弟表示法

![image-20221013105639879](C:\Users\98680\AppData\Roaming\Typora\typora-user-images\image-20221013105639879.png)



##### 二叉树

###### 五种形态

![image-20221013105743510](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221013105743510.png)



###### 三个结点不同形态

![image-20221013105955122](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221013105955122.png)



###### 线索二叉树

![image-20221013135108447](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221013135108447.png)



###### 二叉排序树

![image-20221013141608235](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221013141608235.png)



###### 哈夫曼树

WPF为最小值的二叉树

 只有叶子结点与有两个孩子的结点

![image-20221022100011815](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221022100011815.png)



######  性质计算



第i层有至多有**2^(i-1)** 个结点



深度为k至多有**2^(k+1) -1**个结点

 

叶子结 点度为n0，度为2的结点为n2，则：**n0=n2+1**



具有n个结点的完全二叉树深度为：**[log2n]**



##### 图形结构

###### 邻接矩阵

![image-20221014104404962](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014104404962.png)

![image-20221014104423576](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014104423576.png)



###### 邻接表

![image-20221014104847743](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014104847743.png)

![image-20221014104902055](C:\Users\98680\Desktop\学习笔记\数构\img\image-20221014104902055.png)









